<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Market Analysis Dashboard</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            background-color: #f8f9fa;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        .dashboard {
            max-width: 1200px;
            margin: 2rem auto;
            padding: 1rem;
        }
        .status-container {
            margin: 1rem 0;
            padding: 1rem;
            border-radius: 8px;
            background-color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .results-container {
            display: none;
            margin-top: 2rem;
        }
        .chart-container {
            background-color: white;
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .status-update {
            margin: 0.5rem 0;
            padding: 0.5rem;
            border-left: 4px solid #007bff;
            background-color: #f8f9fa;
        }
        .ticker-card {
            margin-bottom: 1rem;
        }
        .sentiment-positive { color: #28a745; }
        .sentiment-negative { color: #dc3545; }
        .sentiment-neutral { color: #6c757d; }
        .demo-notice {
            background-color: #fff3cd;
            color: #856404;
            padding: 0.75rem;
            margin-bottom: 1rem;
            border-radius: 0.25rem;
            border: 1px solid #ffeeba;
        }
    </style>
</head>
<body>
    <div class="dashboard">
        <h1 class="mb-4">Market Analysis Dashboard v4</h1>
        
        <div class="demo-notice">
            <strong>Demo Mode:</strong> This application is running with mock data. In a production environment, you would connect to real financial data APIs.
        </div>
        
        <div class="d-grid gap-2">
            <button id="startAnalysis" class="btn btn-primary btn-lg">
                Start Market Analysis
            </button>
        </div>

        <div id="statusContainer" class="status-container">
            <h3>Status Updates</h3>
            <div id="statusUpdates"></div>
            <div class="progress mt-3" style="display: none;">
                <div class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar" style="width: 0%"></div>
            </div>
        </div>

        <div id="resultsContainer" class="results-container">
            <h3>Analysis Results</h3>
            
            <div class="row">
                <div class="col-md-6">
                    <div class="chart-container">
                        <h4>Top Positive Sentiment Stocks</h4>
                        <canvas id="sentimentChart"></canvas>
                    </div>
                </div>
                <div class="col-md-6">
                    <div class="chart-container">
                        <h4>Predicted Price Changes</h4>
                        <canvas id="predictionsChart"></canvas>
                    </div>
                </div>
            </div>

            <div class="chart-container">
                <h4>Detailed Analysis</h4>
                <div id="detailedResults" class="row"></div>
            </div>
        </div>
    </div>

    <script>
        let analysisInProgress = false;
        
        // Check for previous analysis results
        document.addEventListener('DOMContentLoaded', () => {
            const savedResults = localStorage.getItem('lastAnalysisResults');
            if (savedResults) {
                try {
                    const results = JSON.parse(savedResults);
                    addStatusUpdate('Found previous analysis results. Click "Start Market Analysis" to run a new analysis.');
                } catch (error) {
                    console.error('Error parsing saved results:', error);
                }
            }
        });

        function addStatusUpdate(message) {
            const statusDiv = document.createElement('div');
            statusDiv.className = 'status-update';
            statusDiv.textContent = message;
            document.getElementById('statusUpdates').appendChild(statusDiv);
        }

        function updateProgress(percent) {
            const progressBar = document.querySelector('.progress-bar');
            progressBar.style.width = `${percent}%`;
            progressBar.parentElement.style.display = 'flex';
        }

        function displayResults(data) {
            const resultsContainer = document.getElementById('resultsContainer');
            resultsContainer.style.display = 'block';

            // Process correlations and predictions
            const correlations = data.analysis.correlations;
            const predictions = data.analysis.predictions;

            // Check if we have data to display
            if (Object.keys(correlations).length === 0 || Object.keys(predictions).length === 0) {
                addStatusUpdate("No analysis data available. This may be due to limited data in the news articles.");
                return;
            }

            // Prepare data for sentiment chart
            const sentimentData = Object.entries(correlations)
                .map(([ticker, articles]) => ({
                    ticker,
                    avgSentiment: articles.reduce((sum, a) => sum + a.sentiment, 0) / articles.length
                }))
                .sort((a, b) => b.avgSentiment - a.avgSentiment)
                .slice(0, 10);

            // Create sentiment chart
            new Chart(document.getElementById('sentimentChart'), {
                type: 'bar',
                data: {
                    labels: sentimentData.map(d => d.ticker),
                    datasets: [{
                        label: 'Average Sentiment',
                        data: sentimentData.map(d => d.avgSentiment),
                        backgroundColor: 'rgba(54, 162, 235, 0.6)'
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true
                        }
                    }
                }
            });

            // Prepare data for predictions chart
            const predictionsData = Object.entries(predictions)
                .map(([ticker, data]) => ({
                    ticker,
                    change: data.predicted_change_percent
                }))
                .sort((a, b) => Math.abs(b.change) - Math.abs(a.change))
                .slice(0, 10);

            // Create predictions chart
            new Chart(document.getElementById('predictionsChart'), {
                type: 'bar',
                data: {
                    labels: predictionsData.map(d => d.ticker),
                    datasets: [{
                        label: 'Predicted Change %',
                        data: predictionsData.map(d => d.change),
                        backgroundColor: d => d > 0 ? 'rgba(40, 167, 69, 0.6)' : 'rgba(220, 53, 69, 0.6)'
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true
                        }
                    }
                }
            });

            // Display detailed results
            const detailedResults = document.getElementById('detailedResults');
            detailedResults.innerHTML = '';

            Object.entries(correlations)
                .filter(([ticker]) => predictions[ticker])
                .forEach(([ticker, articles]) => {
                    const prediction = predictions[ticker];
                    const avgSentiment = articles.reduce((sum, a) => sum + a.sentiment, 0) / articles.length;
                    
                    const card = document.createElement('div');
                    card.className = 'col-md-6 col-lg-4 ticker-card';
                    card.innerHTML = `
                        <div class="card">
                            <div class="card-body">
                                <h5 class="card-title">${ticker}</h5>
                                <p class="card-text">
                                    <strong>Current Price:</strong> $${prediction.current_price.toFixed(2)}<br>
                                    <strong>Predicted Price:</strong> $${prediction.predicted_price.toFixed(2)}<br>
                                    <strong>Predicted Change:</strong> 
                                    <span class="${prediction.predicted_change_percent > 0 ? 'sentiment-positive' : 'sentiment-negative'}">
                                        ${prediction.predicted_change_percent.toFixed(2)}%
                                    </span><br>
                                    <strong>Average Sentiment:</strong> 
                                    <span class="${avgSentiment > 0 ? 'sentiment-positive' : 'sentiment-negative'}">
                                        ${avgSentiment.toFixed(2)}
                                    </span>
                                </p>
                            </div>
                        </div>
                    `;
                    detailedResults.appendChild(card);
                });
        }

        // Simplified sentiment analysis function
        function analyzeSentiment(text) {
            // This is a very basic sentiment analysis
            // In a real app, you'd use a more sophisticated library
            const positiveWords = ['up', 'increase', 'growth', 'positive', 'gain', 'profit', 'success', 'bullish', 'strong', 'higher'];
            const negativeWords = ['down', 'decrease', 'fall', 'negative', 'loss', 'fail', 'risk', 'bearish', 'weak', 'lower'];
            
            let score = 0;
            const words = text.toLowerCase().split(/\s+/);
            
            words.forEach(word => {
                if (positiveWords.includes(word)) score += 1;
                if (negativeWords.includes(word)) score -= 1;
            });
            
            return score / Math.max(words.length, 1); // Normalize by text length
        }
        
        // Simplified stock prediction function
        function predictStockMovement(priceHistory, sentiment) {
            // Very simplified prediction model
            // In a real app, you'd use a more sophisticated algorithm
            const lastPrice = priceHistory[priceHistory.length - 1];
            const priceChange = priceHistory[priceHistory.length - 1] - priceHistory[0];
            const momentum = priceChange / Math.max(priceHistory[0], 0.01);
            
            // Simple formula combining recent momentum and sentiment
            const prediction = lastPrice * (1 + (momentum * 0.5) + (sentiment * 0.5));
            
            return {
                current_price: lastPrice,
                predicted_price: prediction,
                predicted_change_percent: ((prediction - lastPrice) / lastPrice) * 100
            };
        }

        document.getElementById('startAnalysis').addEventListener('click', async () => {
            if (analysisInProgress) return;
            analysisInProgress = true;

            const button = document.getElementById('startAnalysis');
            button.disabled = true;
            button.textContent = 'Analysis in Progress...';

            document.getElementById('statusUpdates').innerHTML = '';
            document.getElementById('resultsContainer').style.display = 'none';
            
            // Add initial status update
            addStatusUpdate('Starting analysis...');
            updateProgress(10);

            try {
                // Step 1: Fetch news data from our serverless function
                addStatusUpdate('Fetching news articles...');
                updateProgress(20);
                
                // Get the base URL for API calls
                const baseUrl = window.location.origin;
                
                // Use the full URL for API calls
                const newsResponse = await fetch(`${baseUrl}/api/news`);
                if (!newsResponse.ok) {
                    // Try to parse the error response as JSON
                    try {
                        const errorData = await newsResponse.json();
                        throw new Error(`Failed to fetch news: ${errorData.error || newsResponse.statusText}`);
                    } catch (jsonError) {
                        // If it's not JSON, get the text response
                        const errorText = await newsResponse.text();
                        throw new Error(`Failed to fetch news: Non-JSON response received. Status: ${newsResponse.status}. Check the API endpoint.`);
                    }
                }
                
                const newsData = await newsResponse.json();
                
                addStatusUpdate(`Fetched ${newsData.articles.length} news articles`);
                if (newsData.source === 'Mock Data') {
                    addStatusUpdate('Using mock news data for demonstration purposes');
                }
                updateProgress(40);
                
                // Step 2: Extract mentioned tickers and analyze sentiment
                addStatusUpdate('Analyzing news sentiment...');
                const tickerMentions = {};
                
                // Simplified list of S&P 500 tickers
                const sp500Tickers = [
                    'AAPL', 'MSFT', 'AMZN', 'GOOGL', 'META', 'TSLA', 'NVDA', 'JPM', 'V', 'UNH',
                    'JNJ', 'WMT', 'PG', 'MA', 'HD', 'BAC', 'XOM', 'AVGO', 'CVX', 'COST'
                ];
                
                newsData.articles.forEach(article => {
                    const text = `${article.title || ''} ${article.description || ''}`;
                    const sentiment = analyzeSentiment(text);
                    
                    sp500Tickers.forEach(ticker => {
                        if (text.includes(ticker)) {
                            if (!tickerMentions[ticker]) {
                                tickerMentions[ticker] = [];
                            }
                            
                            tickerMentions[ticker].push({
                                sentiment,
                                title: article.title,
                                publishedAt: article.publishedAt
                            });
                        }
                    });
                });
                
                updateProgress(60);
                
                // Step 3: Fetch stock data for mentioned tickers
                addStatusUpdate('Fetching stock data...');
                const mentionedTickers = Object.keys(tickerMentions);
                
                if (mentionedTickers.length === 0) {
                    throw new Error('No stock tickers found in news articles');
                }
                
                // Use the full URL for API calls
                const stockResponse = await fetch(`${baseUrl}/api/stocks?tickers=${mentionedTickers.join(',')}`);
                if (!stockResponse.ok) {
                    // Try to parse the error response as JSON
                    try {
                        const errorData = await stockResponse.json();
                        throw new Error(`Failed to fetch stock data: ${errorData.error || stockResponse.statusText}`);
                    } catch (jsonError) {
                        // If it's not JSON, get the text response
                        const errorText = await stockResponse.text();
                        throw new Error(`Failed to fetch stock data: Non-JSON response received. Status: ${stockResponse.status}. Check the API endpoint.`);
                    }
                }
                
                const stockData = await stockResponse.json();
                addStatusUpdate('Using simulated stock price data for demonstration');
                
                updateProgress(80);
                
                // Step 4: Generate predictions
                addStatusUpdate('Generating predictions...');
                const predictions = {};
                
                Object.entries(tickerMentions).forEach(([ticker, articles]) => {
                    if (stockData[ticker] && stockData[ticker].prices && stockData[ticker].prices.length > 0) {
                        const avgSentiment = articles.reduce((sum, a) => sum + a.sentiment, 0) / articles.length;
                        predictions[ticker] = predictStockMovement(stockData[ticker].prices, avgSentiment);
                    }
                });
                
                // Step 5: Prepare results
                const results = {
                    timestamp: new Date().toISOString(),
                    analysis: {
                        news_articles_analyzed: newsData.articles.length,
                        stocks_analyzed: Object.keys(predictions).length,
                        correlations: tickerMentions,
                        predictions: predictions
                    }
                };
                
                // Save to localStorage
                localStorage.setItem('lastAnalysisResults', JSON.stringify(results));
                
                updateProgress(100);
                addStatusUpdate('Analysis complete!');
                
                // Display results
                displayResults(results);
                
            } catch (error) {
                console.error('Analysis error:', error);
                addStatusUpdate(`Error: ${error.message}`);
                updateProgress(100);
            } finally {
                button.disabled = false;
                button.textContent = 'Start Market Analysis';
                analysisInProgress = false;
            }
        });
    </script>
</body>
</html>
